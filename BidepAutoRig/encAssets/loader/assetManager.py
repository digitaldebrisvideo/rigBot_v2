"""
    assetManager by Jennifer Hachigian

    v008 -- now relies on a hard-coded list of show assets generated by _getAssets.py.
    v009 -- relabeled buttons; fixed botched tooltip on ATOM button.
    v012 -- added "roll_toe" to delete animation blacklist
    v013 -- now uses _encLib delete_anim routine
    v014 -- now uses "@_encLib.in_root_namespace" to keep imports within the root namespace
    v015 -- now handles MISC assets more gracefully.
    v017 -- now checks if sys paths are present before attempting to append them.
    v018 -- now works in Maya 2017 as well as Maya 2014.
    v020 -- now sees "libr"
    v021 -- now sees "blkl"
    v022 -- now sees "exgf"
    v023 -- now sees "radi"
    v024 -- now sees "seal"
    v025 -- now externalizes project list as JSON file
    v026 -- now includes hidden project list as "projects_additional" JSON file, with safety check
    v027 -- replaced Qt with direct PySide2 connection to accommodate Mango + Legacy Render Layers.
    v028 -- added Shotgun filter
    v029 -- Shotgun filter now defaults to "on"
    v030 -- refined Shotgun filter to better work with ElongatedManPear and MrNobody
"""

import pymel.core as pm
import os
import time
import datetime
import re
import json

import encLib
reload(encLib)
from PySide2 import QtCore, QtGui, QtWidgets

__author__ = 'jhachigian'

src = r"Z:\data\diablo2\PROJECTS\flas\04_episodes\--assets\chr-flash\3d\publish\rigs\clones"

root = r"Z:\data\diablo2\PROJECTS"
path1 = r"04_episodes\--assets"
path2_list = [r"3d\publish\rigs", r"3d\publish\rig"]
atom_files = r"Z:\data\diablo2\PROJECTS\_library\Generic_Anims"
atom_filters = "atom (*.atom);;All Files (*.*)"

""" define src_folder """
dir_name = os.path.dirname(__file__)
if "current" in dir_name:
    src_folder = dir_name.replace("P:", "//encorevfx-isi01/fac")    # target Burbank server via UNC path
else:
    src_folder = os.path.dirname(__file__)

""" define JSON paths """
show_assets = os.path.join(src_folder, "show_assets.json").replace("\\", "/")
misc_assets = os.path.join(src_folder, "misc_assets.json").replace("\\", "/")
blacklist = os.path.join(src_folder, "blacklist.json").replace("\\", "/")
projects_list = os.path.join(src_folder, "projects_list.json").replace("\\", "/")
projects_add = os.path.join(src_folder, "projects_additional.json").replace("\\", "/")

'''
========================================================================
---->  Global Variables  <----
========================================================================
'''
TOOLS_PATH = os.path.dirname(__file__)

WINDOW_TITLE = 'Asset Manager'
WINDOW_VERSION = 1.31
WINDOW_NAME = 'assetManager_tool_window'

UI_FILE_PATH = os.path.join(TOOLS_PATH, 'assetManager.ui')
UI_OBJECT, BASE_CLASS = encLib.get_pyside_class(UI_FILE_PATH)

projectsFolder = r"Z:\data\diablo2\PROJECTS"

'''
========================================================================
---->  Create/Connect UI Functionality  <----
========================================================================
'''


def has_rig(p, x):
    for path2 in path2_list:
        test = os.path.join(p, x, path2)
        if os.path.exists(test) and os.path.isdir(test) and os.listdir(test):
            return True
    return False


def get_set_nodes(key):
    sets = [x for x in pm.ls(type='objectSet') if x.type() == 'objectSet' and
            x.restriction() == 'none' and x.name().lower().find("ctrl") != -1 and
            x.name().lower().find(key) != -1]
    nodes = []
    for s in sets:
        nodes += [x for x in pm.sets(s, query=True) if x not in nodes]
    return nodes


def has_string(x, li):
    for s in li:
        if x.lower().find(s) != -1:
            return True
    return False


def load_atom_plugin():
    li = pm.pluginInfo(query=True, listPlugins=True)
    if li is None or "atomImportExport" not in li:
        pm.loadPlugin("atomImportExport")


def get_json_object(p, typ="dict"):
    """
    Open JSON file and return contents.

    :param p: String - path to JSON file
    :param typ: String - type of data
    :return: JSON contents or empty type.
    """
    print("Opening: {0}".format(p))
    with open(p, "r") as fp:
        contents = json.load(fp)
    if contents:
        return contents
    if typ == "dict":
        return {}
    return []


def get_projects_additional():
    li = []
    hidden = get_json_object(projects_add)
    for h in hidden:
        test = os.path.join(projectsFolder, h)
        if not os.path.exists(test):
            continue
        try:
            os.listdir(test)
        except WindowsError:
            continue
        li.append(h)
    return li


def get_projects():
    projects = get_json_object(projects_list)
    projects += get_projects_additional()
    projects += ["MISC"]
    return projects


def get_show(d):
    if d["rig_paths"]:
        pattern = re.compile("(?<=/PROJECTS/)[a-z0-9]{4}(?=/)")
        li = pattern.findall(d["rig_paths"][0])
        if li:
            return li[0]
    return d["project"]


'''
========================================================================
---->  ASSET MANAGER CLASS  <----
========================================================================
'''


class AssetManager(BASE_CLASS, UI_OBJECT):
    def __init__(self, parent=encLib.get_maya_window()):
        super(AssetManager, self).__init__(parent)
        self.setupUi(self)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.setWindowTitle('{0} {1}'.format(WINDOW_TITLE, str(WINDOW_VERSION)))
        """ init data """
        print("Init data...")
        self.projects = get_projects()
        self.assets = get_json_object(show_assets)
        self.data = {}
        self.sg = encLib.get_shotgun_client()
        self.namespaces = {}
        self.misc_assets = get_json_object(misc_assets)
        self.blacklist = get_json_object(blacklist, typ="list")
        """ init workspace """
        print("Loading ATOM plugin...")
        load_atom_plugin()
        """ init UI """
        print("Init UI...")
        self.init_namespaces()
        self.update_table()
        self.update_ghosting()
        path = pm.sceneName()
        self.project_dict = encLib.getProjectDict(path)
        if self.project_dict["isValid"]:
            code = encLib.get_shot_prefix()
            self.sg_rigs = encLib.get_shotgun_rigs_dict(self.sg, code)
            if self.sg_rigs:
                # pass
                self.sgCheckBox.setChecked(True)
            else:
                self.sgCheckBox.setEnabled(False)
            self.init_projects()
        else:
            self.sg_rigs = {}
            self.init_projects()
            self.sgCheckBox.setEnabled(False)
        """ hook up UI """
        print("Connect UI...")
        self.show()
        self.update()
        self.progBar.setVisible(False)
        self.showListWidget.itemSelectionChanged.connect(self.update)
        self.assetsListWidget.itemClicked.connect(self.update_src)
        self.srcListWidget.itemSelectionChanged.connect(self.status_report_timestamp)
        self.tableWidget.cellClicked.connect(self.update_selection)
        self.tableWidget.itemSelectionChanged.connect(self.update_ghosting)
        self.opAssetDirButton.clicked.connect(self.open_asset_folder)
        self.removeButton.clicked.connect(self.remove_references)
        self.unloadButton.clicked.connect(self.unload_references)
        self.loadButton.clicked.connect(self.load_references)
        self.reloadButton.clicked.connect(self.reload_references)
        self.sgCheckBox.stateChanged.connect(self.init_projects)
        self.replaceButton.clicked.connect(self.replace_references)
        self.importButton.clicked.connect(self.import_references)
        self.atomButton.clicked.connect(self.import_atom)
        self.deleteButton.clicked.connect(self.delete_anim)
        self.closeButton.clicked.connect(self.close)

    def status_update(self, text):
        self.status.setText(text)
        self.status.repaint()

    def init_projects(self):
        if self.sgCheckBox.isChecked():
            # li = [x["project"] for x in self.sg_rigs.values()]
            li = [get_show(x) for x in self.sg_rigs.values()]
            projects = list(set(li))
            projects.sort()
        else:
            projects = self.projects
        self.showListWidget.clear()
        self.showListWidget.addItems(projects)
        if self.project_dict["isValid"] and self.project_dict["show"] in projects:
            index = projects.index(self.project_dict["show"])
        else:
            index = 0
        self.showListWidget.setCurrentRow(index)

    def init_namespaces(self):
        li = pm.ls(recursive=True, type="reference")
        refs = [x for x in li if x.referenceFile() is not None]
        for ref in refs:
            pth = pm.referenceQuery(ref, filename=True)
            nms = pm.cmds.file(pth, query=True, namespace=True)
            key = nms
            # nms = pm.referenceQuery(ref, namespace=True)
            # key = nms[1:]
            self.namespaces[key] = {}
            self.namespaces[key]['filename'] = pth
            self.namespaces[key]['namespace'] = nms
            self.namespaces[key]['reference'] = ref.name()
            self.namespaces[key]['isLoaded'] = pm.referenceQuery(ref, isLoaded=True)

    def update_table(self):
        # from pprint import pprint
        # pprint(self.namespaces)
        self.tableWidget.clear()
        self.tableWidget.setHorizontalHeaderLabels(["Namespace", "Asset Folder", "Filename"])
        self.tableWidget.setColumnWidth(0, 100)
        self.tableWidget.setColumnWidth(1, 150)
        li = self.namespaces.keys()
        li.sort()
        rowcount = len(li)
        self.tableWidget.setRowCount(rowcount)
        brush = QtGui.QBrush()
        brush.setColor(QtGui.QColor('gray'))
        for row in xrange(rowcount):
            nms = li[row]
            pth = self.namespaces[nms]['filename']
            ldd = self.namespaces[nms]['isLoaded']
            bits = pth.split("/")
            try:
                asset = bits[7]
            except IndexError:
                asset = "MISC"
            if "-" not in asset:
                asset = "MISC"
            filename = os.path.basename(pth)[:-3]
            item0 = QtWidgets.QTableWidgetItem(nms)
            item1 = QtWidgets.QTableWidgetItem(asset)
            item2 = QtWidgets.QTableWidgetItem(filename)
            if not ldd:
                for item in [item0, item1, item2]:
                    item.setForeground(brush)
            self.tableWidget.setItem(row, 0, item0)
            self.tableWidget.setItem(row, 1, item1)
            self.tableWidget.setItem(row, 2, item2)

    def update_selection(self, row):
        key = self.tableWidget.item(row, 0).text()
        pth = self.namespaces[key]['filename']
        bits = pth.split("/")
        show = bits[4]
        try:
            asset = bits[7]
        except IndexError:
            asset = "MISC"
        if "-" not in asset:
            show = "MISC"
            asset = "MISC"
        items = [self.showListWidget.item(i).text() for i in range(self.showListWidget.count())]
        if show in items:
            i = items.index(show)
            self.showListWidget.setCurrentRow(i)
            i = 0
            for x in xrange(self.assetsListWidget.count()):
                if self.assetsListWidget.item(x).text() == asset:
                    i = x
                    break
            self.assetsListWidget.setCurrentRow(i)

    def update_ghosting(self):
        li = self.tableWidget.selectedItems()
        state = bool(li)
        self.removeButton.setEnabled(state)
        self.replaceButton.setEnabled(state)
        self.loadButton.setEnabled(state)
        self.unloadButton.setEnabled(state)
        self.reloadButton.setEnabled(state)
        self.atomButton.setEnabled(state)
        self.deleteButton.setEnabled(state)

    def open_asset_folder(self):
        show = self.showListWidget.currentItem().text()
        asset = self.assetsListWidget.currentItem().text()
        if show == "MISC":
            p = self.misc_assets[asset]
            if os.path.exists(p):
                os.system("explorer.exe " + p)
        else:
            test_path = os.path.join(projectsFolder, show, path1, asset)
            for path2 in path2_list:
                p = os.path.join(test_path, path2)
                if os.path.exists(p):
                    os.system("explorer.exe " + p)

    def update(self):
        self.update_assets()
        self.update_src()
        self.status_report_timestamp()

    def update_assets(self):
        show = self.showListWidget.currentItem().text()
        self.assetsListWidget.clear()
        self.status.clear()
        if show == "MISC":
            folders = self.misc_assets.keys()
        else:
            if self.sgCheckBox.isChecked():
                # li = [x["asset_folder"] for x in self.sg_rigs.values() if x["project"] == show]
                li = [x["asset_folder"] for x in self.sg_rigs.values() if get_show(x) == show]
                folders = list(set(li))
                folders.sort()
            else:
                folders = []
                if show in self.assets:
                    folders = self.assets[show]
                else:
                    test_path = os.path.join(projectsFolder, show, path1)
                    if os.path.exists(test_path):
                        dirs = os.listdir(test_path)
                        dirs.sort()
                        maximum = len(dirs)
                        self.progBar.setMaximum(maximum)
                        self.progBar.reset()
                        self.progBar.setVisible(True)
                        inc = 0
                        for x in dirs:
                            inc += 1
                            self.status_update("Inspecting: " + x)
                            if x.startswith(("chr-", "prp-", "veh-")) and has_rig(test_path, x):
                                folders.append(x)
                            self.progBar.setValue(inc)
                        self.assets[show] = folders[:]
                        self.progBar.setVisible(False)
        if folders:
            folders.sort()
            self.assetsListWidget.addItems(folders)
            self.assetsListWidget.setCurrentRow(0)

    def is_assigned_in_shotgun(self, show, asset, filename):
        # contains_show = [x for x in self.sg_rigs.values() if x["project"] == show]
        contains_show = [x for x in self.sg_rigs.values() if get_show(x) == show]
        if not contains_show:
            return False
        contains_asset = [x for x in contains_show if x["asset_folder"] == asset]
        if not contains_asset:
            return False
        contains_filenames = [x["rig_filenames"] for x in contains_asset if x["rig_filenames"]]
        """ if no filenames exist, let 'em all through. """
        if not contains_filenames:
            return True
        """ if specific filenames exist, only let those filenames that are listed through! """
        names = []
        for x in contains_filenames:
            names += x
        if not names:
            return True
        elif filename in names:
            return True
        else:
            return False

    def update_src(self):
        self.status_update("")
        self.srcListWidget.clear()
        sgc = self.sgCheckBox.isChecked()
        if self.assetsListWidget.count() > 0:
            test_paths = []
            self.data = {}
            show = self.showListWidget.currentItem().text()
            asset = self.assetsListWidget.currentItem().text()
            if show == "MISC":
                test_paths.append(self.misc_assets[asset])
            else:
                test_path = os.path.join(projectsFolder, show, path1, asset)
                for path2 in path2_list:
                    test_paths.append(os.path.join(test_path, path2))
            for p in test_paths:
                if os.path.exists(p):
                    files = [x for x in os.listdir(p) if x.lower().endswith((".mb", ".ma"))]
                    if files:
                        for f in files:
                            p2 = os.path.join(p, f)
                            k = f.rsplit(".", 1)[0]
                            if p2 not in self.blacklist:
                                if (sgc and self.is_assigned_in_shotgun(show, asset, k)) or (not sgc):
                                    self.data[k] = p2.replace("\\", "/")
            keys = self.data.keys()
            keys.sort()
            self.srcListWidget.addItems(keys)
            self.srcListWidget.setCurrentRow(0)

    def status_report_timestamp(self):
        if self.srcListWidget.count() > 0:
            key = self.srcListWidget.currentItem().text()
            p = self.data[key]
            mtime = os.path.getmtime(p)
            dt = datetime.datetime.fromtimestamp(mtime)
            timestamp = dt.strftime("%m-%d-%Y %I:%M%p")
            self.status_update(timestamp + " : " + key)

    def get_namespace(self):
        if self.showListWidget.currentItem().text() == "MISC":
            prefix = "misc"
        else:
            asset = self.assetsListWidget.currentItem().text()
            prefix = asset.split("-", 1)[-1]
            prefix = re.sub("[^a-zA-Z0-9_]", "_", prefix)
            """ strip all numbers and shorten the prefix to two characters """
            prefix = re.sub(r"\d+", '', prefix)
            if len(prefix) > 1:
                prefix = prefix[0] + prefix[-1]
        if prefix not in self.namespaces:
            return prefix
        else:
            """ add a number! """
            i = 1
            while i < 1000:  # this condition is for safety's sake only.
                nms = "%s%02d" % (prefix, i)
                if nms not in self.namespaces:
                    return nms
                else:
                    i += 1
        return "NM"  # in the unlikely event that the above routine fails.

    def remove_references(self):
        li = [x.text() for x in self.tableWidget.selectedItems() if x.column() == 0]

        msg = "You are about to remove " + str(len(li)) + " reference(s).\n\n"
        msg += "This is not undoable. Do you want to continue?"
        answer = pm.confirmDialog(title="WARNING",
                                  message=msg,
                                  button=['Yes', 'No'], defaultButton='Yes',
                                  cancelButton='No', dismissString='No')
        if answer == 'Yes':
            selected = [x.shortName() for x in pm.ls(selection=True)]
            li.sort()
            maximum = len(li)
            self.progBar.setMaximum(maximum)
            self.progBar.reset()
            self.progBar.setVisible(True)
            inc = 0
            t = time.time()
            for key in li:
                inc += 1
                pth = self.namespaces[key]['filename']
                print "Removing reference:", pth
                self.status_update("Removing %d of %d: %s" % (inc, maximum, key))
                self.status.repaint()
                pm.cmds.file(pth, removeReference=True)
                del self.namespaces[key]
                self.progBar.setValue(inc)
                delta = int(time.time() - t)
                tmsg = str(datetime.timedelta(seconds=delta))
                self.status_update("Finished removing %d references in: %s" % (maximum, tmsg))
                self.progBar.setVisible(False)
            self.update_table()
            self.update_ghosting()
            """ restore the original selection """
            leftovers = [x for x in selected if pm.objExists(x)]
            pm.select(leftovers)

    def replace_references(self):
        item = self.srcListWidget.currentItem()
        if item:
            data_key = item.text()
            pth = self.data[data_key]
            li = [x.text() for x in self.tableWidget.selectedItems() if x.column() == 0]
            li.sort()
            maximum = len(li)
            self.progBar.setMaximum(maximum)
            self.progBar.reset()
            self.progBar.setVisible(True)
            inc = 0
            t = time.time()
            selected = [x.shortName() for x in pm.ls(selection=True)]
            for key in li:
                inc += 1
                old_path = self.namespaces[key]['filename']
                ref = self.namespaces[key]['reference']
                print "Replacing reference", ref, ":", old_path
                print "\twith:", pth
                self.status_update("Replacing %d of %d: %s" % (inc, maximum, key))
                pm.cmds.file(pth, loadReference=ref)
                self.namespaces[key]['filename'] = pth
                self.progBar.setValue(inc)
                delta = int(time.time() - t)
                tmsg = str(datetime.timedelta(seconds=delta))
                self.status_update("Finished replacing %d references in: %s" % (maximum, tmsg))
                self.progBar.setVisible(False)
            self.update_table()
            self.update_ghosting()
            """ restore as much of the original selection as you can """
            leftovers = [x for x in selected if pm.objExists(x)]
            pm.select(leftovers)

    def unload_references(self):
        li = [x.text() for x in self.tableWidget.selectedItems() if x.column() == 0]
        li.sort()
        maximum = len(li)
        self.progBar.setMaximum(maximum)
        self.progBar.reset()
        self.progBar.setVisible(True)
        inc = 0
        t = time.time()
        selected = [x.shortName() for x in pm.ls(selection=True)]
        for key in li:
            inc += 1
            ref = self.namespaces[key]['reference']
            if self.namespaces[key]['isLoaded']:
                print "Unloading reference:", key
                self.status_update("Unloading %d of %d: %s" % (inc, maximum, key))
                pm.cmds.file(unloadReference=ref)
                self.namespaces[key]['isLoaded'] = False
            self.progBar.setValue(inc)
        delta = int(time.time() - t)
        tmsg = str(datetime.timedelta(seconds=delta))
        self.status_update("Finished unloading %d references in: %s" % (maximum, tmsg))
        self.progBar.setVisible(False)
        self.update_table()
        self.update_ghosting()
        """ restore the original selection """
        leftovers = [x for x in selected if pm.objExists(x)]
        pm.select(leftovers)

    @encLib.in_root_namespace
    def load_references(self, reload_ref=False):
        li = [x.text() for x in self.tableWidget.selectedItems() if x.column() == 0]
        li.sort()
        maximum = len(li)
        selected = [x.shortName() for x in pm.ls(selection=True)]
        self.progBar.setMaximum(maximum)
        self.progBar.reset()
        self.progBar.setVisible(True)
        inc = 0
        t = time.time()
        if reload_ref:
            msg1 = "Reloading"
            msg2 = "reloading"
        else:
            msg1 = "Loading"
            msg2 = "loading"
        for key in li:
            inc += 1
            ref = self.namespaces[key]['reference']
            if not self.namespaces[key]['isLoaded'] or reload_ref:
                print msg1 + " reference:", key
                self.status_update(msg1 + " %d of %d: %s" % (inc, maximum, key))
                pm.cmds.file(loadReference=ref)
                self.namespaces[key]['isLoaded'] = True
            self.progBar.setValue(inc)
        delta = int(time.time() - t)
        tmsg = str(datetime.timedelta(seconds=delta))
        self.status_update("Finished " + msg2 + " %d references in: %s" % (maximum, tmsg))
        self.progBar.setVisible(False)
        self.update_table()
        self.update_ghosting()
        """ restore the original selection """
        pm.select(selected)

    def reload_references(self):
        self.load_references(reload_ref=True)

    @encLib.in_root_namespace
    def import_references(self):
        li = self.srcListWidget.selectedItems()
        if li:
            selected = [x.shortName() for x in pm.ls(selection=True)]
            li.sort()
            maximum = len(li)
            self.progBar.setMaximum(maximum)
            self.progBar.reset()
            self.progBar.setVisible(True)
            inc = 0
            t = time.time()
            for x in li:
                inc += 1
                key = x.text()
                pth = self.data[key]
                nms = self.get_namespace()
                self.namespaces[nms] = {}
                self.namespaces[nms]['filename'] = pth
                print "Importing reference:", pth
                self.status_update("Importing %d of %d: %s as %s" % (inc, maximum, key, nms))
                ref = pm.cmds.file(pth, reference=True, namespace=nms, mergeNamespacesOnClash=False)
                self.namespaces[nms]['namespace'] = pm.referenceQuery(ref, namespace=True)
                self.namespaces[nms]['reference'] = pm.referenceQuery(ref, referenceNode=True)
                self.namespaces[nms]['isLoaded'] = True
            delta = int(time.time() - t)
            tmsg = str(datetime.timedelta(seconds=delta))
            self.status_update("Finished importing %d references in: %s" % (maximum, tmsg))
            self.progBar.setVisible(False)
            self.update_table()
            """ restore the original selection """
            pm.select(selected)

    @encLib.in_root_namespace
    def import_atom(self):
        li = [x.text() for x in self.tableWidget.selectedItems() if x.column() == 0]
        if li:
            selected = [x.shortName() for x in pm.ls(selection=True)]
            files = pm.fileDialog2(fileFilter=atom_filters, dialogStyle=1, startingDirectory=atom_files,
                                   fileMode=1, caption="Please select an ATOM file.")
            if files:
                atom_file = files[0]
                atom_nms = os.path.basename(atom_file).rsplit(".", 1)[0]
                print "Analyzing:", atom_file
                with open(atom_file, "r") as fp:
                    text = fp.read()
                start = re.compile("(?<=startTime )\d+(?=;)").findall(text)[0]
                end = re.compile("(?<=endTime )\d+(?=;)").findall(text)[0]
                print "\tstartTime:", start, "endTime:", end
                pattern = re.compile("(?<=dagNode \{\n  ).*?(?= \d)")
                dag_node_names = pattern.findall(text)
                if dag_node_names:
                    test_name = dag_node_names[0]
                    option_start = "time%s%s;match=string;selected=selectedOnly;" % (start, end)
                    if test_name.find(":") != -1:
                        """ search and replace! """
                        old_nms = test_name.rsplit(":", 1)[0]
                    else:
                        old_nms = None
                    for key in li:
                        print "\tApplying ATOM to:", key
                        nodes = get_set_nodes(key)
                        pm.select(nodes)
                        if old_nms:
                            opt = option_start + "search=%s;replace=%s;" % (old_nms, key)
                        else:
                            opt = option_start + "prefix=%s:;" % key
                        pm.cmds.file(atom_file, i=True, type='atomImport', renameAll=True,
                                     namespace=atom_nms, options=opt)
            """ restore the original selection """
            pm.select(selected)

    def delete_anim(self):
        li = [x.text() for x in self.tableWidget.selectedItems() if x.column() == 0]
        if li:
            msg = "You are about to delete all animation on the selected reference(s).\n\n"
            msg += "This is not undoable. Do you want to continue?"
            answer = pm.confirmDialog(title="WARNING",
                                      message=msg,
                                      button=['Yes', 'No'], defaultButton='Yes',
                                      cancelButton='No', dismissString='No')
            if answer == 'Yes':
                for key in li:
                    nodes = get_set_nodes(key)
                    encLib.delete_anim(nodes)


def launch():
    global asset_manager
    try:
        asset_manager.close()
    except:
        pass
    asset_manager = AssetManager()
