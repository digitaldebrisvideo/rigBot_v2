bipedArm.py  # -*- rigBot: part -*-

import maya.cmds as mc
import maya.mel as mm
import pymel.core as pm

from rigBot import constraint
from rigBot import control
from rigBot import ikChain
from rigBot import pickWalk
from rigBot import ribbon
from rigBot import spaces
from rigBot import utils
from rigBot.partsLibrary import standardPart

reload(utils)
reload(control)
reload(ikChain)
reload(pickWalk)
reload(spaces)
reload(ribbon)
reload(standardPart)

import pymel.core as pm

from rigBot import encoreCommon

reload(encoreCommon)


class OldBipedArm(standardPart.StandardPart):
    """Biped arm module. Includes FK/ IK, twist, stretch and soft IK. There is also bendy, and auto clavicle functionality

        Build Options:
            :side: (str) Side token for this rig part. Defaults to "Lt".
            :name: (str) Optional name. Used as a naming prefix for all nodes in this part. Defaults to "biped".
            :parent: (str) Parent. Defaults to "chest_Mid_jnt".
            :ikHandleParent: (str) Optional IK handle parent for connecting to a foot part. Will default to it's own IK control if the node doesnt exist. Defaults to "".


        Note:
            """

    def __init__(self):
        standardPart.StandardPart.__init__(self)

        self.add_option('name', default=None)
        self.add_option('parent', data_type='hook', default='C_world_JNT')

        self.add_option('ikHandleParent',
                        data_type='hook',
                        default='',
                        tool_tip="Optional IK handle parent for connecting to a " + \
                                 "foot part. Will default to it's own IK control " + \
                                 "if the node doesnt exist.")
        self.add_option('numberTwistJoints',
                        data_type='int',
                        min=0,
                        default=5,
                        tool_tip='Number of twist joints for the upper and lower arms',
                        rebuild_to_modify=True,
                        hidden=1)

        # self.add_option('makeBendy',
        #          data_type='bool',
        #          default=True,
        #          rebuild_to_modify=True,
        #          tool_tip='Add bendy controls.')

        self.add_option('transOrientiation',
                        data_type='enum',
                        default='world',
                        enum='world:downBone',
                        tool_tip='Orient the translates on IK control to the world OR down the bone.')

        self.add_option('pickWalkParent',
                        data_type='string',
                        default='chest_Mid_bind',
                        selectable=True,
                        tool_tip="Sets the pickWalk hierarcy that the animators use.")

    def build_guide(self, **kwargs):
        """This builds your guide."""

        # This builds your guide master and updates your options
        self.create_guide_master(**kwargs)

        prefix = self.prefix
        options = self.options
        mirror_value = self.mirror_value

        pre = prefix
        side = options.get('side')

        side = options.get('side')
        if side == 'L':
            side = 'Lt'
        if side == 'R':
            side == 'Rt'
        if side == 'C':
            side == 'Mid'

        sd = '_' + side

        if side == 'Rt':
            mirror_value = -1

        ctrl_grp = pre + 'bipedArm_' + side + '_guide_CTLS'

        number_twist_jnts = options.get('numberTwistJoints')
        make_bendy = True

        # draw joints

        scapula_aim_zero, scapula_aim_plc, scapula_aim_jnt = self.guide_joint('scapulaAim', constraint_type='point')
        scapula1_zero, scapula1_plc, scapula1_jnt = self.guide_joint('scapulaCtrl', constraint_type='point')
        scapula2_zero, scapula2_plc, scapula2_jnt = self.guide_joint('scapulaEnd', constraint_type='point')
        scapula_target_plc_zero, scapula_target_plc, scapula_target_jnt = self.guide_joint('scapulaTarget',
                                                                                           constraint_type='point')
        scapula_chest_plc_zero, scapula_chest_plc, scapula_chest_jnt = self.guide_joint('scapulaChest',
                                                                                        constraint_type='point')

        clavicle_zero, clavicle_plc, clavicle_jnt = self.guide_joint('clavicle', constraint_type='point')
        clavicle2_zero, clavicle2_plc, clavicle2_jnt = self.guide_joint('clavicleEnd', constraint_type='point')

        shoulder_zero, shoulder_plc, shoulder_jnt = self.guide_joint('shoulder', constraint_type='point')
        elbow_zero, elbow_plc, elbow_jnt = self.guide_joint('elbow', constraint_type='point')
        wrist_zero, wrist_plc, wrist_jnt = self.guide_joint('wrist', constraint_type='point')
        wrist_end_zero, wrist_end_plc, wrist_end_jnt = self.guide_joint('wrist_end', constraint_type='point')

        ik_driver_plc_zero, ik_driver_plc = self.guide_joint('handIk_handle_driver', placer_only=1)
        mc.setAttr(ik_driver_plc_zero + '.visibility', 0)

        # mc.setAttr(ik_driver_plc+'.radius', .01)

        mc.setAttr(ik_driver_plc + '.color', 0.96, 0.71, .01)
        mc.setAttr(ik_driver_plc + '.otherType', 'Arm IK Driver', type='string');
        mc.setAttr(ik_driver_plc + '.type', 18)

        mc.parentConstraint(wrist_jnt, ik_driver_plc_zero)
        mc.setAttr(ik_driver_plc + '.offsetTranslateX', self.mirror_value * 0.25)

        utils.set_attrs(ik_driver_plc, l=1, k=0)

        # position

        mc.setAttr(scapula1_zero + '.tx', 2)
        mc.setAttr(scapula1_zero + '.tz', -1)

        mc.setAttr(scapula_aim_zero + '.tx', 13)
        mc.setAttr(scapula_aim_zero + '.tz', -14)

        mc.setAttr(scapula2_zero + '.tx', 3.5)
        mc.setAttr(scapula2_zero + '.tz', -14)

        mc.setAttr(scapula_target_plc_zero + '.tz', -2)

        mc.setAttr(clavicle_zero + '.tx', .25)

        mc.setAttr(clavicle2_zero + '.tx', 2)
        mc.setAttr(clavicle2_zero + '.tz', -.5)

        mc.setAttr(shoulder_zero + '.tx', 2)
        mc.setAttr(elbow_zero + '.tx', 4)
        mc.setAttr(elbow_zero + '.tz', -.25)

        mc.setAttr(wrist_zero + '.tx', 6)
        mc.setAttr(wrist_end_zero + '.tx', 6.5)

        # constraint scapula
        mc.pointConstraint(scapula_target_plc, scapula2_zero, mo=1)

        # Constraint clavicle
        mc.aimConstraint(clavicle2_plc,
                         clavicle_jnt,
                         n=clavicle_jnt + '_ac',
                         aim=[mirror_value, 0, 0],
                         u=[0, 1, 0],
                         wu=[0, 1, 0],
                         wut='objectRotation',
                         wuo=clavicle_plc)

        # Constraint shoulder
        mc.aimConstraint(elbow_plc,
                         shoulder_jnt,
                         n=shoulder_jnt + '_ac',
                         aim=[mirror_value, 0, 0],
                         u=[0, 0, mirror_value],
                         wut='object',
                         wuo=wrist_plc)

        # Constraint lower arm
        mc.aimConstraint(wrist_plc,
                         elbow_jnt,
                         n=elbow_jnt + '_ac',
                         aim=[mirror_value, 0, 0],
                         u=[0, 0, mirror_value],
                         wut='object',
                         wuo=shoulder_plc)

        mc.aimConstraint(wrist_end_plc,
                         wrist_jnt,
                         n=wrist_jnt + '_ac',
                         aim=[mirror_value, 0, 0],
                         u=[0, 1, 0],
                         wu=[0, 1, 0],
                         wut='objectRotation',
                         wuo=wrist_plc)

        # parent jnts

        mc.parent(scapula2_jnt, scapula1_jnt)
        mc.parent(scapula1_jnt, scapula_aim_jnt)
        mc.parent(scapula_aim_jnt, clavicle_jnt)
        mc.parent(scapula_target_jnt, scapula_chest_jnt)
        mc.parent(shoulder_jnt, clavicle_jnt)
        mc.parent(clavicle2_jnt, clavicle_jnt)
        mc.parent(elbow_jnt, shoulder_jnt)
        mc.parent(wrist_jnt, elbow_jnt)
        mc.parent(wrist_end_jnt, wrist_jnt)

        mc.xform(wrist_end_jnt, a=1, ro=[0, 0, 0])
        mc.setAttr(wrist_end_jnt + '.jo', 0, 0, 0)

        # placers=[scapula_chest_plc,scapula1_plc, scapula_aim_plc,
        #     clavicle2_plc,clavicle_plc,
        #    shoulder_plc, elbow_plc,wrist_plc,
        #     wrist_end_plc, scapula_chest_plc, scapula_target_plc, scapula2_plc]
        #
        # for placer in placers:
        #     utils.set_attrs(placer, 'radius', l=0)
        #     mc.connectAttr (self.guide_master+'.placerSize', placer+'.radius', f=1)

        mc.connectAttr(scapula1_plc + '.t', scapula_aim_plc + '.t')
        utils.set_attrs(scapula_aim_plc, 'tx ty tz', cb=0)

        # mc.setAttr (self.guide_master+'.placerSize', 5)
        # mc.select (placers)
        # mc.select (cl=1)
        # mm.eval ('dgdirty -a')

        # Create twist jnts
        div = 1.0 / (number_twist_jnts + 1)
        nn = (number_twist_jnts - 2)
        divpos = 1.0 / (nn + 1)
        up_twist_zeros, up_twist_plcs, up_twist_jnts = [], [], []
        lo_twist_zeros, lo_twist_plcs, lo_twist_jnts = [], [], []

        for i in range(number_twist_jnts):

            # setup upper arm jnts
            letter = utils.letters[i]
            num = str(i + 1)
            zero, plc, jnt = self.guide_joint('shoulder_twist_' + letter, constraint_type='point')
            up_shp_zero, up_shp_ctrl = self.guide_ctrl('shoulder_shaper_0' + num, shape='pin_circle',
                                                       color='dark_magenta', driver=plc, scale=[5, 5, 5])

            mc.setAttr(zero + '.visibility', 1)
            if up_twist_jnts:
                mc.parent(jnt, up_twist_jnts[-1])
            else:
                mc.parent(jnt, shoulder_jnt)

            up_twist_jnts.append(jnt)
            up_twist_plcs.append(plc)
            up_twist_zeros.append(zero)

            if i == 0:
                x = 0.95
                y = 0.05
                mc.pointConstraint(shoulder_plc, plc, weight=x)
                mc.pointConstraint(elbow_plc, plc, weight=y)
            if i == (number_twist_jnts - 1):
                x = 0.05
                y = 0.95
                mc.pointConstraint(shoulder_plc, plc, weight=x)
                mc.pointConstraint(elbow_plc, plc, weight=y)
            elif i != 0 and i != (number_twist_jnts - 1):
                n = i - 1
                mc.pointConstraint(shoulder_plc, plc, weight=1.0 - (divpos * (n + 1)))
                mc.pointConstraint(elbow_plc, plc, weight=(divpos * (n + 1)))

            # mc.pointConstraint(elbow_plc, plc, weight=(div*(i+1)))
            mc.orientConstraint(shoulder_jnt, plc)

            mc.xform(jnt, a=1, ro=[0, 0, 0])
            mc.setAttr(jnt + '.jo', 0, 0, 0)

            # utils.set_attrs(plc, 't r s', l=1, k=0)

            # set up uplowerper arm jnts
            letter = utils.letters[i]
            zero, plc, jnt = self.guide_joint('elbow_twist_' + letter, constraint_type='point')
            lo_shp_zero, lo_shp_ctrl = self.guide_ctrl('elbow_shaper_0' + num, shape='pin_circle', color='dark_magenta',
                                                       driver=plc, scale=[5, 5, 5])

            mc.setAttr(zero + '.visibility', 0)
            if lo_twist_jnts:
                mc.parent(jnt, lo_twist_jnts[-1])
            else:
                mc.parent(jnt, elbow_jnt)

            lo_twist_jnts.append(jnt)
            lo_twist_plcs.append(plc)
            lo_twist_zeros.append(zero)

            if i == 0:
                mc.pointConstraint(elbow_plc, plc, weight=0.95)
                mc.pointConstraint(wrist_plc, plc, weight=0.05)
            if i == (number_twist_jnts - 1):
                mc.pointConstraint(elbow_plc, plc, weight=0.05)
                mc.pointConstraint(wrist_plc, plc, weight=0.95)
            elif i != 0 and i != (number_twist_jnts - 1):
                n = i - 1
                mc.pointConstraint(elbow_plc, plc, weight=1.0 - (divpos * (n + 1)))
                mc.pointConstraint(wrist_plc, plc, weight=(divpos * (n + 1)))

            mc.orientConstraint(elbow_jnt, plc)
            # mc.setAttr (plc+'.visibility', 0)
            mc.xform(jnt, a=1, ro=[0, 0, 0])
            mc.setAttr(jnt + '.jo', 0, 0, 0)

            utils.set_attrs(plc, 't r s', l=1, k=0)

        if up_twist_jnts:
            mc.parent(elbow_jnt, up_twist_jnts[-1])

        if lo_twist_jnts:
            mc.parent(wrist_jnt, lo_twist_jnts[-1])

        # lock plcs

        utils.set_attrs([shoulder_plc, elbow_plc], 'r s', l=1, k=0)

        # Create ctrls

        scapula1_zero, scapula1_ctrl = self.guide_ctrl(name='scapulaCtrl',
                                                       shape='square',
                                                       color='light_blue',
                                                       driver=scapula1_jnt,
                                                       allow_offset_ctrls=False,
                                                       scale=[3, 3, 3])

        mc.xform(scapula1_ctrl + '.cv[*]', r=1, ro=[0, mirror_value * (90), 0])
        # mc.xform(scapula1_ctrl+'.cv[*]', r=1, t=[0,0,-5])

        scapula_target_zero, scapulatarget_ctrl = self.guide_ctrl(name='scapulaTarget',
                                                                  shape='diamond',
                                                                  color='yellow',
                                                                  driver=scapula_target_jnt,
                                                                  allow_offset_ctrls=False,
                                                                  axis='X',
                                                                  scale=[3, 3, 3])

        scapula_chest_zero, scapulachest_ctrl = self.guide_ctrl(name='scapulaChest',
                                                                shape='sphere',
                                                                color='yellow',
                                                                driver=scapula_chest_jnt,
                                                                allow_offset_ctrls=False,
                                                                axis='X',
                                                                scale=[3, 3, 3])

        shoulder_fk_zero, shoulder_fk_ctrl = self.guide_ctrl(name='shoulderFk',
                                                             shape='cube',
                                                             color='blue',
                                                             driver=shoulder_jnt,
                                                             allow_offset_ctrls=False,
                                                             scale=[5, 5, 5])

        elbow_fk_zero, elbow_fk_ctrl = self.guide_ctrl(name='elbowFk',
                                                       shape='cube',
                                                       color='blue',
                                                       driver=elbow_jnt,
                                                       allow_offset_ctrls=False,
                                                       axis='X',
                                                       scale=[5, 5, 5])

        wrist_fk_zero, wrist_fk_ctrl = self.guide_ctrl(name='wristFk',
                                                       shape='cube',
                                                       color='blue',
                                                       driver=wrist_jnt,
                                                       allow_offset_ctrls=False,
                                                       axis='X',
                                                       scale=[5, 5, 5])

        mc.xform(wrist_fk_ctrl + '.cv[*]', r=1, t=[mirror_value * 0.25, 0, 0])

        color = 'blue'
        if mirror_value < 0:
            color = 'red'

        arm_ik_zero, arm_ik_ctrl = self.guide_ctrl('handIk',
                                                   shape='circle',
                                                   color=color,
                                                   scale=[10, 10, 10],
                                                   axis='X',
                                                   driver=wrist_jnt, )

        wrist_ik_zero, wrist_ik_ctrl = self.guide_ctrl(name='lwrArmTwist',
                                                       shape='arrow_circle',
                                                       color=color,
                                                       driver=wrist_jnt,
                                                       axis='X',
                                                       scale=[1, 1, 1])

        # mc.xform(wrist_ik_ctrl+'.cv[*]', r=1, t=[mirror_value*0.5,0,0])
        mc.xform(wrist_ik_ctrl + '.cv[*]', r=1, ro=[0, 0, mirror_value * 90])

        pv_zero, pv_ctrl = self.guide_ctrl('elbowUpVectorIk', shape='pyramid', color=color, scale=[3, 3, 3],
                                           allow_offset_ctrls=0, create_pivot=0)
        pv_pivot = utils.get_parent(pv_ctrl)
        utils.set_attrs(pv_pivot, 't', l=0)

        # mc.xform(pv_ctrl+'.cv[*]', r=1,  ro=[0,90,0])

        grp = utils.get_parent(pv_pivot)
        noxform = utils.get_parent(pv_zero).replace('CTLS', 'NOX')

        # Constraint pv
        mc.pointConstraint(shoulder_jnt, pv_zero, n=pv_zero + '_pc')
        mc.aimConstraint(wrist_jnt,
                         pv_zero,
                         n=pv_zero + '_ac',
                         aim=[mirror_value, 0, 0],
                         u=[0, 0, -mirror_value],
                         wut='object',
                         wuo=elbow_jnt)

        mc.pointConstraint(elbow_jnt, grp, n=grp + '_pc')
        mc.setAttr(pv_pivot + '.tz', -20)
        mc.orientConstraint(noxform, pv_ctrl, n=pv_ctrl + '_pc')

        utils.set_attrs([pv_ctrl, pv_zero, grp, pv_pivot], 'r t s v', l=1, k=0)
        utils.set_attrs(pv_ctrl, 'tx tz s ', l=0, k=1)

        clavicle_fk_zero, clavicle_fk_ctrl = self.guide_ctrl(name='clavicle',
                                                             shape='semi_circle_shoulder',
                                                             color=color,
                                                             scale=[10, 10, 10],
                                                             driver=clavicle_jnt,
                                                             axis='Y')

        if make_bendy:
            baCtrl = self.guide_ctrl(name='uprArmRibbonMid', shape='arrow_quad', color='yellow', scale=[10, 10, 10],
                                     axis='X')
            bbCtrl = self.guide_ctrl(name='elbowRibbon', shape='arrow_quad', color='yellow', scale=[10, 10, 10],
                                     axis='X')
            bcCtrl = self.guide_ctrl(name='lwrArmRibbonMid', shape='arrow_quad', color='yellow', scale=[10, 10, 10],
                                     axis='X')

            mc.parentConstraint(shoulder_jnt, baCtrl[0], n=baCtrl[0] + '_prc')
            mc.parentConstraint(elbow_jnt, bbCtrl[0], n=bbCtrl[0] + '_prc')
            mc.parentConstraint(elbow_jnt, bcCtrl[0], n=bcCtrl[0] + '_prc')

            mc.pointConstraint(shoulder_jnt, elbow_jnt, baCtrl[1] + '_CONST', n=baCtrl[1] + '_CONST_pc')
            mc.pointConstraint(wrist_jnt, elbow_jnt, bcCtrl[1] + '_CONST', n=bcCtrl[1] + '_CONST_pc')
            oc = mc.orientConstraint(shoulder_jnt, elbow_jnt, bbCtrl[1] + '_CONST', n=bbCtrl[1] + '_CONST_oc')
            mc.setAttr(oc[0] + '.interpType', 2)

            utils.set_attrs(baCtrl + bbCtrl + bcCtrl)
            utils.set_attrs([baCtrl[-1], bbCtrl[-1], bcCtrl[-1]], 't r s', k=1, l=0)

        # ik fk switch ctrl
        switch_zero, switch_ctrl = self.guide_ctrl(name='arm_IK_switch', shape='locator', color='lavendar',
                                                   driver=wrist_jnt)
        mc.setAttr(arm_ik_ctrl + '.numOffsetCtrls', 1)
        mc.setAttr(switch_ctrl + '.t', -20, 10, 0)

        line = mc.createNode('transform', n=pv_ctrl + '_line_REF', p=utils.get_parent(pv_zero))
        control.create_driven_shape(line, [pv_ctrl, elbow_jnt])
        utils.set_draw_override(line, 1)
        # mc.setAttr (self.guide_master+'.')

        self.set_guide(master=self.guide_master)

        # mc.setAttr (self.guide_master+'.ctrlVis', 0)
        # connect plc size to master attr

        bindskel_node = 'shoulder_' + side + '_jnt'
        if mc.objExists(bindskel_node):
            print
            "yes"
            sd = '_' + side + '_'
            suf = 'jnt'
            mc.delete(mc.pointConstraint('scapulaAim' + sd + suf, scapula1_plc))
            mc.delete(mc.pointConstraint('scapulaAim' + sd + suf, scapula_aim_plc))
            if mc.objExists('chest_Mid_bind'):
                mc.delete(mc.pointConstraint('chest_Mid_bind', scapula_chest_plc))
            mc.delete(mc.pointConstraint('scapulaTarget_jnt', scapula_target_plc))

            mc.delete(mc.pointConstraint('clavicle' + sd + 'bind', clavicle_plc))
            mc.delete(mc.pointConstraint('clavicleEnd' + sd + suf, clavicle2_plc))

            mc.delete(mc.pointConstraint('hand' + sd + suf, wrist_plc))
            mc.delete(mc.pointConstraint('handEnd' + sd + suf, wrist_end_plc))

            mc.delete(mc.pointConstraint('elbow' + sd + suf, elbow_plc))
            mc.delete(mc.pointConstraint('shoulder' + sd + suf, shoulder_plc))

        # This finalizes your guide.
        self.finalize_guide()

    def build_rig(self):
        """This builds your anim rig."""
        debug = 1
        # create rig part top nodes
        self.create_part_master()

        # Get all the relevant part info
        prefix = self.prefix
        options = self.options
        anim_ctrls = self.anim_ctrls
        bind_joints = self.bind_joints
        world_scale_attr = self.hooks[0] + '.worldScale'
        hooks = self.hooks
        ctrl_grps = self.ctrl_grps
        jnt_grps = self.jnt_grps

        pre = prefix + '_'

        number_twist_jnts = options.get('numberTwistJoints')
        parent = options.get('parent')
        make_bendy = True
        pickWalk_parent = options.get('pickWalkParent')

        world_orient_trans = options.get('transOrientiation')
        side = options.get('side')
        sd = '_' + side + '_'

        mirror = 1
        color = 'blue'
        if side == 'Rt':
            mirror = -1
            color = 'red'

        scap_aim_jnt = pre + 'scapulaAim_JNT'
        scapula1_jnt = pre + 'scapulaCtrl_JNT'
        scapula2_jnt = pre + 'scapulaEnd_JNT'
        scapula_target_jnt = pre + 'scapulaTarget_JNT'
        scapula_chest_jnt = pre + 'scapulaChest_JNT'
        clavicle_jnt = pre + 'clavicle_JNT'
        clavicle2_jnt = pre + 'clavicleEnd_JNT'
        shoulder_jnt = pre + 'shoulder_JNT'
        elbow_jnt = pre + 'elbow_JNT'
        wrist_jnt = pre + 'wrist_JNT'
        wrist_end_jnt = pre + 'wrist_end_JNT'

        shoulder_twist_jnts = mc.ls(pre + 'shoulder_twist_*_JNT')
        elbow_twist_jnts = mc.ls(pre + 'elbow_twist_*_JNT')

        # # Create Scapula Rig

        scapula_dict = {side: {"bind": pre + "scapulaCtrl_JNT"}}

        # /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        # # make the scapula up objects and add to hierarchy
        loc_name = pre + "scapulaUpObj_loc"
        aim_name = scap_aim_jnt
        bnd_name = clavicle_jnt
        aim = pm.PyNode(aim_name)
        loc = pm.spaceLocator(name=loc_name)
        encoreCommon.match_xyz(loc, aim)
        pm.move(0, 20, 0, loc, relative=True, worldSpace=True)
        pm.parent(loc, bnd_name)
        scapula_dict[side]["aimJnt"] = aim
        scapula_dict[side]["upObj"] = loc

        loc_name = pre + "scapulaTarget_LOC"
        grp_name = pre + "scapulaTarget_GRP"
        loc = pm.spaceLocator(name=loc_name)
        grp = pm.group(name=grp_name)
        encoreCommon.match_xyz(grp, scapula_target_jnt)
        pm.parent(grp, scapula_chest_jnt)
        scapula_dict[side]["targetLoc"] = loc
        scapula_dict[side]["targetGrp"] = grp

        # constrain scapula targets
        tgt1 = clavicle2_jnt
        tgt2 = scapula_chest_jnt
        grp = scapula_dict[side]["targetGrp"]
        pm.pointConstraint(tgt1, grp, maintainOffset=True, skip=("x", "z"), weight=1.0)
        pm.pointConstraint(tgt2, grp, maintainOffset=True, skip=("x", "z"), weight=0.5)

        # setup scapula aim_constraints():
        tgt = scapula_dict[side]["targetLoc"]
        jnt = scapula_dict[side]["aimJnt"]
        amir = -1
        if side == 'Rt':
            amir = 1
        upv = (0, amir, 0)
        amv = (amir, 0, 0)
        upo = scapula_dict[side]["upObj"]
        aim = pm.aimConstraint(tgt, jnt, aimVector=amv, upVector=upv, worldUpType="object", worldUpObject=upo)
        pm.delete(aim)

        tgt = scapula_dict[side]["targetLoc"]
        jnt = scapula_dict[side]["aimJnt"]
        upv = (0, amir, 0)
        amv = (amir, 0, 0)
        upo = scapula_dict[side]["upObj"]
        aim = pm.aimConstraint(tgt, jnt, aimVector=amv, upVector=upv, worldUpType="object", worldUpObject=upo)
        pm.delete(aim)
        pm.makeIdentity(jnt, apply=True, translate=True, rotate=True, scale=True, normal=0, preserveNormals=True)
        pm.aimConstraint(tgt, jnt, aimVector=amv, upVector=upv, worldUpType="object", worldUpObject=upo)

        # create scapula anim ctrls
        name = pre + 'scapulaCtrl_CTL'
        scapula1_zero, scapula1_ctrl, scapula1_offsets, scapula1_last_node = self.anim_ctrl(name)

        cir_name = scapula1_ctrl
        grp_name = scapula1_zero
        jnt = scap_aim_jnt
        bnd = scapula1_jnt

        pm.parentConstraint(jnt, scapula1_zero)
        pm.parentConstraint(scapula1_ctrl, scapula1_jnt)
        pm.transformLimits(jnt, rotationY=(-360, 0), enableRotationY=(False, True))

        scap_zero = (pre + 'scapulaCtrl_CTL_ZERO')
        mc.parent(scap_zero, ctrl_grps[0])

        # /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        # Create FK ctrls
        name = pre + 'clavicle_CTL'
        clavicle_zero, clavicle_ctrl, clavicle_offsets, clavicle_last_node = self.anim_ctrl(name)

        name = pre + 'shoulderFk_CTL'
        shoulder_fk_zero, shoulder_fk_ctrl, shoulder_fk_offsets, shoulder_fk_last_node = self.anim_ctrl(name)

        name = pre + 'elbowFk_CTL'
        elbow_fk_zero, elbow_fk_ctrl, elbow_fk_offsets, elbow_fk_last_node = self.anim_ctrl(name)

        name = pre + 'wristFk_CTL'
        wrist_fk_zero, wrist_fk_ctrl, wrist_fk_offsets, wrist_fk_last_node = self.anim_ctrl(name)

        # Create IK ctrls
        name = pre + 'handIk_CTL'
        arm_ik_zero, arm_ik_ctrl, arm_ik_offsets, arm_ik_last_node = self.anim_ctrl(name, node_type='joint')

        arm_ik_last_node = mc.createNode('transform', p=arm_ik_last_node, n=pre + 'handIk_handle_driver_JNT')

        name = pre + 'lwrArmTwist_CTL'
        wrist_ik_zero, wrist_ik_ctrl, wrist_ik_offsets, wrist_ik_last_node = self.anim_ctrl(name)

        name = pre + 'elbowUpVectorIk_CTL'
        loc = utils.snap_locator(name + '_REF')
        mc.setAttr(loc + '.sx', self.mirror_value)
        pv_zero, pv_ctrl, pv_offsets, pv_last_node = self.anim_ctrl(name, match_position=loc)

        name = pre + 'arm_IK_switch_CTL'
        switch_zero, switch_ctrl, switch_offsets, switch_last_node = self.anim_ctrl(name)

        mc.delete(loc)

        shoulder_grp = mc.createNode('transform', n=shoulder_jnt + '_base_GRP', p=clavicle_jnt)
        mc.delete(mc.parentConstraint(shoulder_jnt, shoulder_grp))
        mc.parent(shoulder_jnt, shoulder_grp)

        # if make_bendy:
        elbowRibbonACtrl = self.anim_ctrl(pre + 'uprArmRibbonMid_CTL')
        elbowRibbonBCtrl = self.anim_ctrl(pre + 'elbowRibbon_CTL')
        elbowRibbonCCtrl = self.anim_ctrl(pre + 'lwrArmRibbonMid_CTL')
        mc.parent(elbowRibbonACtrl[0], elbowRibbonBCtrl[0], elbowRibbonCCtrl[0], ctrl_grps[0])

        # orient arm ik ctrl
        tmp_grp = mc.group(arm_ik_ctrl)
        mc.parent(tmp_grp, w=1)

        mc.xform(arm_ik_zero, a=1, ro=[0, 0, 0])
        mc.setAttr(arm_ik_zero + '.s', self.mirror_value, 1, 1)

        utils.set_attrs(arm_ik_ctrl, 'jo', l=0)
        mc.parent(arm_ik_ctrl, arm_ik_ctrl + '_OFF')
        mc.delete(tmp_grp)

        if world_orient_trans == 'downBone':
            utils.set_attrs(arm_ik_ctrl + '_ZERO', 'ry', k=1, l=0)
            utils.set_attrs(arm_ik_ctrl, 'joy', k=1, l=0)
            mc.setAttr(arm_ik_ctrl + '_ZERO.ry', mc.getAttr(arm_ik_ctrl + '.joy'))

            utils.set_attrs(arm_ik_ctrl + '_ZERO', 'ry', k=0, l=1)
            utils.set_attrs(arm_ik_ctrl, 'joy', k=0, l=1)

        # parent fk ctrls
        mc.parent(shoulder_fk_zero, clavicle_ctrl)
        mc.parent(elbow_fk_zero, shoulder_fk_ctrl)
        mc.parent(wrist_fk_zero, elbow_fk_ctrl)

        # parent ik ctrls
        mc.parent(wrist_ik_zero, arm_ik_last_node)

        # NOW create ik fk chain setup
        shoulder_ik_jnt = mc.duplicate(shoulder_jnt, po=1, n=shoulder_jnt.replace('shoulder', 'shoulder_IK'))[0]
        elbow_ik_jnt = mc.duplicate(elbow_jnt, po=1, n=elbow_jnt.replace('elbow', 'elbow_IK'))[0]
        wrist_ik_jnt = mc.duplicate(wrist_jnt, po=1, n=wrist_jnt.replace('wrist', 'hand_IK'))[0]

        shoulder_fk_jnt = mc.duplicate(shoulder_jnt, po=1, n=shoulder_jnt.replace('shoulder', 'shoulder_FK'))[0]
        elbow_fk_jnt = mc.duplicate(elbow_jnt, po=1, n=elbow_jnt.replace('elbow', 'elbow_FK'))[0]
        wrist_fk_jnt = mc.duplicate(wrist_jnt, po=1, n=wrist_jnt.replace('wrist', 'hand_FK'))[0]

        mc.parent(elbow_ik_jnt, shoulder_ik_jnt)
        mc.parent(wrist_ik_jnt, elbow_ik_jnt)

        mc.orientConstraint(shoulder_fk_last_node, shoulder_ik_jnt, mo=1)
        mc.orientConstraint(wrist_fk_last_node, wrist_ik_jnt, mo=1)

        ori_par = mc.createNode('transform', p=elbow_ik_jnt, n=elbow_ik_jnt + '_orient_drv_GRP')
        ori = mc.createNode('transform', p=ori_par, n=elbow_ik_jnt + '_orient_DRV')
        mc.parent(ori_par, elbow_fk_zero)

        mc.orientConstraint(elbow_fk_ctrl, ori, mo=1)
        mc.connectAttr(ori + '.r', elbow_ik_jnt + '.r')

        ik_handle = mc.ikHandle(sj=shoulder_ik_jnt, ee=wrist_ik_jnt, s='sticky', n=pre + 'handIk')[0]
        mc.poleVectorConstraint(pv_ctrl, ik_handle)

        ikChain.create_fk_ik_switch(switch_ctrl, ik_handle, shoulder_fk_zero, [arm_ik_zero, pv_zero])
        mc.parent(ik_handle, arm_ik_last_node)
        mc.setAttr(switch_ctrl + '.IK', 1)
        mc.hide(ik_handle)

        mc.addAttr(arm_ik_ctrl, ln='twist', k=1)

        mc.connectAttr(arm_ik_ctrl + '.twist', ik_handle + '.twist')
        if self.mirror_value < 0.0:
            utils.connect_negative(arm_ik_ctrl + '.twist', ik_handle + '.twist')

        # Create soft ik

        # new case for new hook
        ik_handle_grp = mc.createNode('transform', p=arm_ik_last_node, n=ik_handle + '_GRP')
        mc.parent(ik_handle_grp, jnt_grps[1])
        mc.parent(ik_handle, ik_handle_grp)
        mc.parentConstraint(arm_ik_last_node, hooks[1], mo=1)

        ik_joints = [shoulder_ik_jnt, elbow_ik_jnt, wrist_ik_jnt]
        ik_ctrl = arm_ik_ctrl

        ik_handle_parent = ikChain.create_soft_ik(ik_ctrl, ik_joints, ik_handle)

        # Create IK wrist orient switch
        jnt_follow_par = mc.duplicate(wrist_ik_ctrl + '_MOCAP', po=1, n=wrist_ik_zero + '_jnt_follow_par')[0]
        ctrl_follow_par = mc.duplicate(wrist_ik_ctrl + '_MOCAP', po=1, n=wrist_ik_zero + '_ikCtrl_follow_par')[0]

        jnt_follow = mc.duplicate(wrist_ik_ctrl + '_MOCAP', po=1, n=wrist_ik_zero + '_jnt_follow')[0]
        ctrl_follow = mc.duplicate(wrist_ik_ctrl + '_MOCAP', po=1, n=wrist_ik_zero + '_ikCtrl_follow')[0]

        mc.parent(ctrl_follow, ctrl_follow_par)
        mc.parent(jnt_follow, jnt_follow_par)
        mc.parent(jnt_follow_par, elbow_ik_jnt)

        oc = mc.orientConstraint(jnt_follow, ctrl_follow, wrist_ik_ctrl + '_MOCAP')[0]
        mc.setAttr(oc + '.interpType', 2)

        mc.addAttr(arm_ik_ctrl, ln='isolateWristOrientation', min=0, max=1, k=1)

        mdl = mc.createNode('multDoubleLinear', n=oc + '_mdl')
        mc.connectAttr(switch_ctrl + '.IK', mdl + '.input1', f=1)
        mc.connectAttr(arm_ik_ctrl + '.isolateWristOrientation', mdl + '.input2', f=1)
        # mc.connectAttr(switch_zero+'.visibility', 0)

        mc.connectAttr(mdl + '.output', oc + '.w0')
        utils.connect_reverse(oc + '.w0', oc + '.w1')

        # connect ik blend to wrist orientConstraint
        oc = mc.orientConstraint(wrist_ik_last_node, wrist_ik_jnt, mo=1)[0]
        mc.setAttr(oc + '.interpType', 2)

        mc.connectAttr(switch_ctrl + '.IK', oc + '.w1')
        utils.connect_reverse(switch_ctrl + '.IK', oc + '.w0')

        # setup uparm FK orient
        shoulder_fk_orient_grp = shoulder_fk_ctrl + '_MOCAP'
        iso_follow_par = mc.duplicate(shoulder_fk_orient_grp, po=1, n=shoulder_fk_orient_grp + '_isolate_par')[0]
        iso_follow = mc.duplicate(shoulder_fk_orient_grp, po=1, n=shoulder_fk_orient_grp + '_isolate')[0]

        mc.parent(iso_follow, iso_follow_par)
        mc.parent(iso_follow_par, clavicle_zero)

        oc = mc.orientConstraint(shoulder_fk_zero, shoulder_fk_orient_grp, mo=1)[0]
        oc = mc.orientConstraint(iso_follow, shoulder_fk_orient_grp, mo=1)[0]
        mc.setAttr(oc + '.interpType', 2)

        mc.addAttr(shoulder_fk_ctrl, ln='isolateArmOrientation', min=0, max=1, k=1)
        mc.connectAttr(shoulder_fk_ctrl + '.isolateArmOrientation', oc + '.w1')
        utils.connect_reverse(oc + '.w1', oc + '.w0')

        # setup autoclav
        mc.parentConstraint(clavicle_last_node, clavicle_jnt, mo=1)

        up_shaper_zeros, up_shaper_ctrls, up_shaper_jnts = [], [], []
        lo_shaper_zeros, lo_shaper_ctrls, lo_shaper_jnts = [], [], []
        # Create twist
        if shoulder_twist_jnts:
            ikChain.upper_twist(utils.get_parent(shoulder_ik_jnt), shoulder_ik_jnt, elbow_ik_jnt, shoulder_jnt,
                                elbow_jnt, shoulder_twist_jnts)
            ikChain.lower_twist(elbow_ik_jnt, wrist_ik_jnt, elbow_jnt, elbow_twist_jnts, wrist_jnt)

            ikChain.stretch_twist_jnts(shoulder_ik_jnt, elbow_ik_jnt, shoulder_twist_jnts)
            ikChain.stretch_twist_jnts(elbow_ik_jnt, wrist_ik_jnt, elbow_twist_jnts)

            for i in range(0, number_twist_jnts):
                letter = utils.letters[i]
                num = str(i + 1)
                shaper_zero, shaper_ctrl, shaper_offset, shaper_last_node = self.anim_ctrl(
                    '{0}_shoulder_shaper_0{1}_CTL'.format(prefix, num))
                mc.parent(shaper_zero, ctrl_grps[0])
                up_shaper_zeros.append(shaper_zero[i])
                up_shaper_ctrls.append(shaper_ctrl[i])

                shaper_zero, shaper_ctrl, shaper_offset, shaper_last_node = self.anim_ctrl(
                    '{0}_elbow_shaper_0{1}_CTL'.format(prefix, num))
                mc.parent(shaper_zero, ctrl_grps[0])
                lo_shaper_zeros.append(shaper_zero[i])
                lo_shaper_ctrls.append(shaper_ctrl[i])


        else:
            mc.parentConstraint(shoulder_ik_jnt, shoulder_fk_jnt, shoulder_jnt, mo=1)
            mc.parentConstraint(elbow_ik_jnt, elbow_fk_jnt, elbow_jnt, mo=1)
            mc.parentConstraint(wrist_ik_jnt, wrist_fk_jnt, wrist_jnt, mo=1)

        # create stretch
        ikChain.biped_stretch(arm_ik_ctrl,
                              arm_ik_last_node,
                              pv_ctrl,
                              switch_ctrl,
                              shoulder_fk_ctrl,
                              elbow_fk_ctrl,
                              wrist_fk_ctrl,
                              shoulder_ik_jnt,
                              elbow_ik_jnt,
                              wrist_ik_jnt,
                              ik_handle,
                              pin_attr_name='pinElbow',
                              shift_attr_name='shiftElbow')

        control.create_driven_shape(pv_ctrl, elbow_ik_jnt, replace=False)

        # lastly set up auto clavicle
        mc.parent(clavicle_jnt, jnt_grps[0])

        # Create all joints
        auto_clavicle = mc.duplicate(clavicle_jnt, po=1, n=clavicle_jnt + '_AUTO')[0]
        auto_elbow = mc.duplicate(elbow_jnt, po=1, n=elbow_jnt + '_AUTO')[0]
        auto_wrist = mc.duplicate(wrist_jnt, po=1, n=wrist_jnt + '_AUTO')[0]

        up_auto_clavicle = mc.duplicate(clavicle_jnt, po=1, n=clavicle_jnt + '_upper_AUTO')[0]
        up_auto_elbow = mc.duplicate(elbow_jnt, po=1, n=elbow_jnt + '_upper_AUTO')[0]

        mc.parent(auto_elbow, auto_clavicle)
        mc.parent(auto_wrist, auto_elbow)
        mc.parent(up_auto_elbow, up_auto_clavicle)

        # Create ik
        up_auto_ik_handle = \
        mc.ikHandle(sj=up_auto_clavicle, ee=up_auto_elbow, s='sticky', n=pre + 'arm_auto_clav_upper_IK')[0]
        auto_ik_handle = mc.ikHandle(sj=auto_clavicle, ee=auto_wrist, s='sticky', n=pre + 'arm_auto_clav_IK')[0]

        mc.parent(auto_ik_handle, ik_handle_grp)
        mc.parent(up_auto_ik_handle, auto_clavicle)
        mc.setAttr(up_auto_ik_handle + '.poleVector', 0, 0, 0)

        mc.poleVectorConstraint(pv_ctrl, auto_ik_handle)
        mc.connectAttr(arm_ik_ctrl + '.twist', auto_ik_handle + '.twist')
        if self.mirror_value < 0.0:
            utils.connect_negative(arm_ik_ctrl + '.twist', auto_ik_handle + '.twist')

        # Create atrtrs
        mc.addAttr(clavicle_ctrl, ln='autoClavicle', min=0, max=1, k=0)

        mc.addAttr(clavicle_ctrl, ln='clavUpLimit', min=0, dv=90, k=1)
        mc.addAttr(clavicle_ctrl, ln='clavDownLimit', min=0, dv=45, k=1)
        mc.addAttr(clavicle_ctrl, ln='clavFrontLimit', min=0, dv=90, k=1)
        mc.addAttr(clavicle_ctrl, ln='clavBackLimit', min=0, dv=90, k=1)

        mc.connectAttr(clavicle_ctrl + '.clavUpLimit', up_auto_clavicle + '.maxRotZLimit')
        mc.connectAttr(clavicle_ctrl + '.clavBackLimit', up_auto_clavicle + '.maxRotYLimit')
        utils.connect_negative(clavicle_ctrl + '.clavDownLimit', up_auto_clavicle + '.minRotZLimit')
        utils.connect_negative(clavicle_ctrl + '.clavFrontLimit', up_auto_clavicle + '.minRotYLimit')

        mc.setAttr(up_auto_clavicle + '.maxRotYLimitEnable', 1)
        mc.setAttr(up_auto_clavicle + '.minRotYLimitEnable', 1)
        mc.setAttr(up_auto_clavicle + '.maxRotZLimitEnable', 1)
        mc.setAttr(up_auto_clavicle + '.minRotZLimitEnable', 1)

        mc.hide(auto_clavicle, up_auto_clavicle, up_auto_ik_handle, auto_ik_handle)

        auto_follow_grp = mc.duplicate(clavicle_ctrl + '_CONST', po=1, n=clavicle_ctrl + '_AUTO_GRP')[0]
        auto_follow = mc.duplicate(clavicle_ctrl + '_CONST', po=1, n=clavicle_ctrl + '_AUTO')[0]
        stable = mc.duplicate(clavicle_ctrl + '_CONST', po=1, n=clavicle_ctrl + '_STABLE')[0]

        mc.parent(auto_follow, auto_follow_grp)
        mc.parent(auto_follow_grp, up_auto_clavicle)

        oc = mc.orientConstraint(stable, auto_follow, clavicle_ctrl + '_CONST')[0]
        mc.connectAttr(clavicle_ctrl + '.autoClavicle', oc + '.w1')
        utils.connect_reverse(clavicle_ctrl + '.autoClavicle', oc + '.w0')

        mc.setAttr(oc + '.interpType', 2)
        #
        # if make_bendy:

        mc.parentConstraint(shoulder_jnt, elbowRibbonACtrl[0], mo=1, n=elbowRibbonACtrl[0] + '_prc')
        mc.pointConstraint(shoulder_ik_jnt, elbow_ik_jnt, elbowRibbonACtrl[1] + '_CONST', mo=1,
                           n=elbowRibbonACtrl[1] + '_CONST_pc')

        mc.parentConstraint(elbow_jnt, elbowRibbonCCtrl[0], mo=1, n=elbowRibbonCCtrl[0] + '_prc')
        mc.pointConstraint(elbow_jnt, wrist_jnt, elbowRibbonCCtrl[1] + '_CONST', mo=1,
                           n=elbowRibbonCCtrl[1] + '_CONST_pc')

        mc.parentConstraint(elbow_jnt, elbowRibbonBCtrl[0], mo=1, n=elbowRibbonBCtrl[0] + '_prc')
        oc = mc.orientConstraint(shoulder_jnt, elbow_jnt, elbowRibbonBCtrl[1] + '_CONST', mo=1,
                                 n=elbowRibbonBCtrl[1] + '_CONST_pc')[0]
        mc.setAttr(oc + '.interpType', 2)

        bendy_joints_drivers = [shoulder_jnt] + shoulder_twist_jnts + [elbow_jnt] + elbow_twist_jnts + [wrist_jnt]
        bendy_ctrls = [elbowRibbonACtrl[-1], elbowRibbonBCtrl[-1], elbowRibbonCCtrl[-1]]
        noxform_grp = self.noxform_grp

        ikChain.biped_bendy(bendy_joints_drivers, bendy_ctrls, False, noxform_grp, ctrl_driver=elbowRibbonBCtrl[1])

        # make bendy stretchy
        partpre = pre + 'armIKFK'
        swctrl = ikChain.make_fkikSwitch_connection_attrs(partpre=partpre, side=side, source_ctrl=None,
                                                          tag_name='switch',
                                                          snapTo=switch_ctrl,
                                                          add_attrs=['autoStretchy', 'bendyCtrlVis', 'shaperCtrlVis', ])

        swgrp = swctrl[0].replace('_CTL', '_grp')
        # utils.snap_to_transform(switch_ctrl, swgrp)
        mc.setAttr(swgrp + '.t', 5, 20, -20)
        mc.setAttr(swgrp + '.rx', -90)
        mc.setAttr(swgrp + '.s', 0.5, 0.5, 0.5)
        mc.parent(swgrp + 'Offset', ctrl_grps[0])
        mc.connectAttr(swctrl[0] + '.FK_IK', switch_ctrl + '.IK')

        mc.addAttr(swctrl[0], ln='animControl', dt='string')

        mc.parentConstraint(wrist_jnt, switch_zero, mo=1)
        mc.parent(clavicle_zero, arm_ik_zero, pv_zero, switch_zero, ctrl_grps[0])

        utils.set_attrs([shoulder_fk_ctrl, wrist_ik_ctrl, elbow_fk_ctrl, wrist_fk_ctrl], ' s v', l=1, k=0)
        utils.set_attrs(elbow_fk_ctrl, 'ro', l=1, k=0)
        utils.set_attrs(pv_ctrl, 'r s v ro', l=1, k=0)
        utils.set_attrs(elbow_fk_ctrl, 'ro', l=1, k=0)
        utils.set_attrs(switch_ctrl, 't r s v ro', l=1, k=0)
        utils.set_attrs(clavicle_ctrl, 's', l=1, k=0)

        utils.set_attrs(arm_ik_offsets + [arm_ik_ctrl], ' s  ro jo radius', l=1, k=0, cb=0)
        for c in arm_ik_offsets + [arm_ik_ctrl]:
            mc.setAttr(c + '.radius', k=0, cb=0)

        # spaces
        spaces.tag(arm_ik_ctrl, default=0)
        spaces.tag(pv_ctrl, default=0)
        spaces.tag(clavicle_ctrl, default=0)

        # tag_attrs_to_lock

        jnts = [clavicle_jnt, shoulder_jnt] + [elbow_jnt] + [wrist_jnt, wrist_end_jnt]

        # movable pivot
        control.create_movable_pivot(arm_ik_ctrl, ctrl_type='joint')

        utils.tag_attrs_to_lock(swctrl[0], attrs='tx ty tz rx ry rz sx sy sz')

        # setup wrist joint////////////////////////////////////////////////////////////////////////////////////////

        offsets = {
            side: {"areas": {"Top": (0, 2.5, 0), "Bottom": (0, -2.5, 0), "Inner": (0, 0, 2.5), "Outer": (0, 0, -2.5)},
                   "nodes": {pre + "wristFixTopBottom_UTmd": {"type": "multiplyDivide",
                                                              "attrs": {"input2Y": 0.05,
                                                                        "input2Z": 0.05}},
                             pre + "wristFixTopBottom_UTclmp": {"type": "clamp",
                                                                "attrs": {"minG": 0, "maxG": 5,
                                                                          "minB": -5, "maxB": 0}},
                             pre + "wristFixInnerOuter_UTmd": {"type": "multiplyDivide",
                                                               "attrs": {"input2Y": -0.025,
                                                                         "input2Z": -0.025}},
                             pre + "wristFixInnerOuter_UTclmp": {"type": "clamp",
                                                                 "attrs": {"minG": 0, "maxG": 5,
                                                                           "minB": -5, "maxB": 0}}},
                   "connections": [
                       [pre + "wrist_JNT.rotateZ", pre + "wristFixTopBottom_UTmd.input1Y"],
                       [pre + "wrist_JNT.rotateZ", pre + "wristFixTopBottom_UTmd.input1Z"],
                       [pre + "wristFixTopBottom_UTmd.outputY",
                        pre + "wristFixTopBottom_UTclmp.inputG"],
                       [pre + "wristFixTopBottom_UTmd.outputZ",
                        pre + "wristFixTopBottom_UTclmp.inputB"],
                       [pre + "wristFixTopBottom_UTclmp.outputG",
                        pre + "wristFixTop_JNT.translateY"],
                       [pre + "wristFixTopBottom_UTclmp.outputB",
                        pre + "wristFixBottom_JNT.translateY"],

                       [pre + "wrist_JNT.rotateY", pre + "wristFixInnerOuter_UTmd.input1Y"],
                       [pre + "wrist_JNT.rotateY", pre + "wristFixInnerOuter_UTmd.input1Z"],
                       [pre + "wristFixInnerOuter_UTmd.outputY",
                        pre + "wristFixInnerOuter_UTclmp.inputG"],
                       [pre + "wristFixInnerOuter_UTmd.outputZ",
                        pre + "wristFixInnerOuter_UTclmp.inputB"],
                       [pre + "wristFixInnerOuter_UTclmp.outputG",
                        pre + "wristFixInner_JNT.translateZ"],
                       [pre + "wristFixInnerOuter_UTclmp.outputB",
                        pre + "wristFixOuter_JNT.translateZ"]]}}

        mc.select(arm_ik_last_node)
        mc.joint(name=pre + 'hand_JNT')
        mc.select(cl=1)
        hnd_name = pre + "hand_JNT"
        wri_name = pre + "wrist_JNT"
        hnd = pm.PyNode(hnd_name)
        wri = pm.PyNode(wri_name)

        # mak partial bind joints
        fix_name = pre + "wristFix_partial_JNT"
        jnt = encoreCommon.make_joint(fix_name, zero=True, world=True, clear_selection=True)
        # jnt.setAttr("drawStyle",0)
        jnt.setParent(wri, relative=True)
        pm.makeIdentity(jnt, apply=True, translate=True, rotate=True, scale=True, normal=False, preserveNormals=True)
        offset = 0.002
        if side == "Rt":
            offset *= -1
        jnt.setAttr("translateY", offset)
        ori = pm.orientConstraint(hnd, wri, jnt, maintainOffset=True, skip="x", weight=1.0)
        ori.setAttr("interpType", 2)
        offsets[side]["partial_bind_joint"] = jnt

        # make_offset_hierarchies(
        d = offsets[side]
        pbj = d["partial_bind_joint"]
        d["offset_hierarchies"] = {}
        wrist_fix_binds = []
        for area in d["areas"]:
            grp_name = pre + "wristFix{0}_GRP".format(area)
            bnd_name = pre + "wristFix{0}_JNT".format(area)
            bnd = encoreCommon.make_joint(bnd_name, zero=True, world=True, clear_selection=True)
            bnd.setAttr("drawStyle", 0)
            grp = pm.group(name=grp_name)
            grp.setParent(pbj, relative=True)
            grp.setAttr("translate", d["areas"][area])
            d["offset_hierarchies"][area] = (grp, bnd)
            wrist_fix_binds.append(bnd)

        # create_nodes(side):
        encoreCommon.debug_print("setupWrists: create_nodes:", dbg=debug)
        d = offsets[side]["nodes"]
        for key in d:
            typ = d[key]["type"]
            encoreCommon.debug_print("\tCreating " + typ + " node: " + key, dbg=debug)
            n = pm.createNode(typ, name=key)
            for attr in d[key]["attrs"]:
                v = d[key]["attrs"][attr]
                n.setAttr(attr, v)

        # make_connections
        encoreCommon.debug_print("setupWrists: make_connections", dbg=debug)
        cons = offsets[side]["connections"]
        for con in cons:
            encoreCommon.debug_print("\tConnecting: " + con[0] + "to:" + con[1], dbg=debug)
            pm.connectAttr(con[0], con[1])

        # //////////////////////////////////////////////////////////////////////////////////////////////////////////

        # setup elbow vj  and fix Joints

        flip = 1
        if side == 'Rt':
            flip = -1

        front_name = pre + "elbowFrontFix_JNT"
        back_name = pre + "elbowBackFix_JNT"
        # encoreCommon.add_volume_joint (elbow_jnt)

        vjname = pre + "elbow_VJ_JNT"
        vjpar = utils.get_parent(shoulder_jnt)
        sources = (shoulder_twist_jnts[-1], elbow_twist_jnts[0])
        vjjnt = mc.joint(name=vjname)
        mc.select(clear=1)
        mc.parent(vjjnt, vjpar)
        mc.orientConstraint(sources, vjjnt, mo=0)
        mc.pointConstraint(elbow_jnt, vjjnt, mo=0)

        for name in [front_name, back_name]:
            pm.select(vjjnt)
            pm.joint(name=name)
        d = {front_name: {"translateZ": [{"cd": elbow_ik_jnt + ".rotateY", "keys": [(0, 4 * flip), (-40, 8 * flip)]}]},
             back_name: {"translateZ": [{"cd": elbow_ik_jnt + ".rotateY", "keys": [(0, -4 * flip), (-40, -8 * flip)]}]}}

        for obj in d:
            for attr in d[obj]:
                for x in d[obj][attr]:
                    for key in x["keys"]:
                        cd = x["cd"]
                        pm.setDrivenKeyframe(obj, attribute=attr, currentDriver=cd, driverValue=key[0], value=key[1],
                                             inTangentType='linear', outTangentType='linear')
        # mc.setAttr(front_name+".radius",1)
        # mc.setAttr(back_name+".radius",1)
        # mc.setAttr(vjjnt+".radius",5)

        # now constrain shaper joints
        shapers = ['shoulder', 'elbow']
        for shaper in shapers:
            for i in range(0, number_twist_jnts):
                letter = utils.letters[i]
                num = str(i + 1)
                twist_jnt = '{0}_{1}_twist_{2}_JNT'.format(prefix, shaper, letter)
                num = str(i + 1)
                zero = '{0}_{1}_shaper_0{2}_CTL_ZERO'.format(prefix, shaper, num)
                mc.parentConstraint(twist_jnt, zero, mo=1)
                jnt = mc.createNode('joint', n=zero.replace('CTL_ZERO', 'JNT'), p=jnt_grps[0])
                ctrl = zero.replace('_ZERO', '')
                utils.snap_to_transform(ctrl, jnt)
                mc.parentConstraint(ctrl, jnt, mo=0)

        bndjnts = [scapula1_jnt, clavicle_jnt, wrist_jnt]
        mc.select(bndjnts, up_shaper_jnts, lo_shaper_jnts)
        bindjnts_set = mc.sets(name=pre + 'arm_bindJoints')
        mc.select(cl=1)

        shoulder_fk_pc = mc.pointConstraint(shoulder_fk_ctrl, shoulder_ik_jnt, mo=1)
        if mc.objExists(shoulder_ik_jnt + '.blendParent1'):
            rev = mc.createNode('reverse', name=pre + 'blendParent_rev')
            mc.connectAttr(switch_ctrl + '.FKIK', rev + '.inputX')
            mc.connectAttr(rev + '.outputX', shoulder_ik_jnt + '.blendParent1')

        elbow_fk_pc = mc.pointConstraint(elbow_fk_ctrl, elbow_ik_jnt, mo=1)
        if mc.objExists(elbow_ik_jnt + '.blendParent1'):
            mc.connectAttr(rev + '.outputX', elbow_ik_jnt + '.blendParent1')

        # hand_fk_pc=mc.pointConstraint (wrist_fk_ctrl, wrist_ik_jnt, mo=1)
        # if mc.objExists(wrist_ik_jnt+'.blendParent1'):
        #     mc.connectAttr(rev+'.outputX',wrist_ik_jnt+'.blendParent1')

        # constme=mc.ls ('*OFF_anim')
        # utils.set_attrs(constme, 't r s v', l=0, k=1, cb=1)
        # This sets up the pickwalk hierarchy the animators will work with. Subject to change.
        # pickWalk.attribute_tag(ctrl, parent)
        ikChain.tag_match_function(switch_ctrl, 'bipedArm')
        ikChain.create_snapto_node(pv_ctrl, elbow_ik_jnt)
        ikChain.create_snapto_node(arm_ik_ctrl, wrist_ik_jnt)

        pickWalk.attribute_tag(shoulder_fk_ctrl, clavicle_ctrl)
        pickWalk.attribute_tag(wrist_fk_ctrl, elbow_fk_ctrl)

        pickWalk.attribute_tag(arm_ik_ctrl, pv_ctrl)
        pickWalk.attribute_tag(pv_ctrl, clavicle_ctrl)

        pickWalk.attribute_tag(clavicle_ctrl, pickWalk_parent)
        pickWalk.attribute_tag(switch_ctrl, arm_ik_ctrl)

        pickWalk.attribute_tag(elbowRibbonCCtrl[-1], elbowRibbonBCtrl[-1])
        pickWalk.attribute_tag(elbowRibbonBCtrl[-1], elbowRibbonACtrl[-1])
        pickWalk.attribute_tag(elbowRibbonACtrl[-1], clavicle_ctrl)

        self.finalize_part()
        # bndjnts=[scapula1_jnt, clavicle_jnt, wrist_jnt, front_name, back_name, vjname ]
        # for wf in (wrist_fix_binds, lwrArmShaperJnts, upArmShaperJnts):
        #     bndjnts.append (wf)

        # for bj in bndjnts:
        #     if '_JNT' in bj:
        #         nn=mc.rename (bj, bj.replace ('_JNT', '_bind'))

        # mc.select (bndjnts)
        # mc.sets (name=pre+'arm_bindJoints')

        ctrls_set = []
        anim_controls = mc.ls('*.animControl')
        if anim_controls:
            for ac in anim_controls:
                ctrl = ac.split('.')[0]
                ctrls_set.append(ctrl)

        # utils.set_attrs(switch_ctrl, 'visibility', l=0, k=1)
        # mc.setAttr  (switch_zero+'.visibility', 0)
        # utils.set_attrs(switch_ctrl, 'visibility', l=1, k=0)
        swctrlnn = mc.rename(switch_ctrl, switch_ctrl.replace('anim', 'driver'))
        utils.set_attrs(swctrlnn, 'v', l=0, k=1)
        mc.setAttr(swctrlnn + '.visibility', 0)

        offsetik = pre + 'handIk_CTL'
        master = self.part_master
        mc.addAttr(offsetik, ln='offsetCtrlVis', min=0, max=1, dv=1, k=0)
        if mc.objExists(master + '.offsetCtrlsVis'):
            mc.connectAttr(offsetik + '.offsetCtrlVis', master + '.offsetCtrlsVis')

        # mc.addAttr (wrist_ik_jnt)

        # adjs=mc.ls ('*ADJ*')
        # for adj in adjs:
        #     par=utils.get_parent (adj)
        #     if 'ADJ' in par or  'NEG' in par:
        #         par=utils.get_parent (par)
        #         if 'ADJ' in par or  'NEG' in par:
        #             par=utils.get_parent(par)
        #             if 'ADJ' in par or  'NEG' in par:
        #                 par=utils.get_parent(par)
        #     if not mc.objExists (par+'.showOffsetCtrl'):
        #         mc.addAttr (par, ln='showOffsetCtrl', min=0, max=0, dv=0, k=1)
        #     # utils.set_attrs(adj+'Shape', 'v', l=0, k=1, cb=1)
        #     mc.connectAttr (par+'.showOffsetCtrl', adj+'.lodVisibility', force=1)
        #     utils.set_attrs(par+'offset', l=0, k=1, cb=1)
        #     utils.set_attrs(adj, 'v', l=1, k=0, cb=0)
